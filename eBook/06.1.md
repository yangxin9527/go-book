# 6.1 介绍


鉴于可读性的需求，最好把 `main()` 函数写在文件的前面，其他函数按照一定逻辑顺序进行编写（例如函数被调用的顺序）。


DRY 原则的，即(Don't Repeat Yourself)，意思是执行特定任务的代码只能在程序里面出现一次


Go 里面有三种类型的函数：  

- 普通的带有名字的函数
- 匿名函数或者lambda函数（参考 [第 6.8 节](06.8.md)）
- 方法（Methods，参考 [第 10.6 节](10.6.md)）

除了 `main()`、`init()` 函数外，其它所有类型的函数都可以有参数与返回值。函数参数、返回值以及它们的类型被统称为*函数签名*。


`Function` 是 `pack1` 包里面的一个函数，括号里的是被调用函数的*实参* (argument)：这些值被传递给被调用函数的*形参*（parameter，参考[第 6.2 节](06.2.md)）。函数被调用的时候，这些实参将被复制（简单而言）然后传递给被调用函数。


函数重载 (function overloading) 指的是可以编写多个同名函数，**只要它们拥有不同的形参/或者不同的返回值**，在 Go 里面函数重载是不被允许的。这将导致一个编译错误：

    funcName redeclared in this book, previous declaration at lineno

Go 语言不支持这项特性的主要原因是函数重载需要进行多余的类型匹配影响性能；没有重载意味着只是一个简单的函数调度。所以你需要给不同的函数使用不同的名字，我们通常会根据函数的特征对函数进行命名（参考 [第 11.12.5 节](11.12.md)）。

如果需要申明一个在外部定义的函数，你只需要给出函数名与函数签名，不需要给出函数体：

```go
func flushICache(begin, end uintptr) // implemented externally
```

**函数也可以以申明的方式被使用，作为一个函数类型**，就像：

```go
type binOp func(int, int) int
```

在这里，不需要函数体 `{}`。

函数是一等值 (first-class value)：它们可以赋值给变量，就像 `add := binOp` 一样。

这个变量知道自己指向的函数的签名，所以给它赋一个具有不同签名的函数值是不可能的。

函数值 (functions value) 之间可以相互比较：如果它们引用的是相同的函数或者都是 `nil` 的话，则认为它们是相同的函数。

函数不能在其它函数里面声明（不能嵌套），不过我们可以通过使用匿名函数（参考 [第 6.8 节](06.8.md)）来破除这个限制。

目前 Go 没有泛型 (generic) 的概念，也就是说它不支持那种支持多种类型的函数。不过在大部分情况下可以通过接口 (interface)，特别是空接口与类型选择（type switch，参考 [第 11.12 节](11.12.md)）与/或者通过使用反射（reflection，参考 [第 6.8 节](06.8.md)）来实现相似的功能。使用这些技术将导致代码更为复杂、性能更为低下，所以在非常注意性能的的场合，最好是为每一个类型单独创建一个函数，而且代码可读性更强。

## 链接

- [目录](directory.md)
- 上一节：[函数 (function)](06.0.md)
- 下一节：[函数参数与返回值](06.2.md)
